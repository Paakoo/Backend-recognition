@face_recognition_bp.route('/api/upload', methods=['POST'])
@jwt_required()
def upload():
    start_time = time.time()
    current_user = get_jwt_identity()  # Get username from JWT token
    
    try:
        if 'file' not in request.files:
            return jsonify({'error': 'No file part'}), 400
            
        file = request.files['file']
        if file.filename == '':
            return jsonify({'error': 'No selected file'}), 400
            
        if file and allowed_file(file.filename):
            # Generate filename and save temp file
            filename = secure_filename(file.filename)
            filename = get_incremental_filename(UPLOAD_FOLDER, filename)
            file_path = os.path.join(UPLOAD_FOLDER, filename)
            temp_path = os.path.join(UPLOAD_FOLDER, f"temp_{filename}")
            file.save(temp_path)

            # Anti-spoofing check first
            spoof_start = time.time()
            spoof_result = DeepFace.extract_faces(
                img_path=temp_path,
                anti_spoofing=True
            )
            spoof_time = time.time() - spoof_start

            if not spoof_result or len(spoof_result) == 0:
                os.remove(temp_path)
                return jsonify({'error': 'No face detected'}), 400

            face_data = spoof_result[0]
            is_real = face_data.get('is_real', False)
            spoof_confidence = float(face_data.get('confidence', 0))

            # if not is_real:
            #     os.remove(temp_path)
            #     return jsonify({
            #         'status': 'failed',
            #         'message': 'Fake face detected',
            #         'anti_spoofing': {
            #             'is_real': is_real,
            #             'confidence': spoof_confidence,
            #         }
            #     }), 400

            # Continue with face detection if real face
            detection_start = time.time()
            image = cv2.imread(temp_path)
            detector = MTCNN()
            faces = detector.detect_faces(image)
            detection_time = time.time() - detection_start

            if faces:
                # Time face processing
                process_start = time.time()
                x, y, width, height = faces[0]['box']
                margin = 20
                x = max(x - margin, 0)
                y = max(y - margin, 0)
                width += margin * 2
                height += margin * 2
                
                cropped_face = image[y:y+height, x:x+width]
                resized_face = cv2.resize(cropped_face, (250, 250))
                cv2.imwrite(file_path, resized_face)
                process_time = time.time() - process_start

                # Continue with embedding generation and matching...
                embedding_start = time.time()
                embedding_obj = DeepFace.represent(
                    img_path=file_path,
                    model_name=FACE_RECOGNITION_MODEL,
                    detector_backend=FACE_DETECTION_MODEL,
                    enforce_detection=True,
                    align=True
                )
                embedding_time = time.time() - embedding_start

                # Time matching
                matching_start = time.time()
                embeddings = load_h5_embeddings()
                current_embedding = np.array(embedding_obj[0]['embedding'])
                
                matched_name, similarity = find_matching_face(current_embedding, embeddings)
                matching_time = time.time() - matching_start
                
                os.remove(temp_path)
                total_time = time.time() - start_time

                if matched_name:
                    # Connect to database to verify user
                    connection = pymysql.connect(**db_config)
                    with connection.cursor() as cursor:
                        sql = "SELECT nama FROM karyawan WHERE nama = %s"
                        cursor.execute(sql, (current_user,))
                        user = cursor.fetchone()

                        if not user:
                            return jsonify({
                                'status': 'error',
                                'message': 'User not authenticated'
                            }), 401

                        if matched_name == current_user:
                            return jsonify({
                                'status': 'success',
                                'message': 'Face matched with authenticated user',
                                'data': {
                                    'matched_name': matched_name,
                                    'confidence': float(similarity),
                                    'filename': filename
                                },
                                'timing': {
                                    'spoofing': f"{spoof_time:.3f}s",
                                    'detection': f"{detection_time:.3f}s",
                                    'processing': f"{process_time:.3f}s",
                                    'embedding': f"{embedding_time:.3f}s",
                                    'matching': f"{matching_time:.3f}s",
                                    'total': f"{time.time() - start_time:.3f}s"
                                }
                            }), 200
                        else:
                            return jsonify({
                                'status': 'error',
                                'message': 'Face matched with different user',
                                'matched_user': matched_name,
                                'current_user': current_user
                            }), 401

                return jsonify({
                    'status': 'error',
                    'message': 'No face match found'
                }), 404

    except Exception as e:
        return jsonify({
            'status': 'error',
            'message': str(e)
        }), 500
    finally:
        if 'connection' in locals():
            connection.close()

    return jsonify({'error': 'Invalid file type'}), 400